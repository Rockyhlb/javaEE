/**
 * @BelongsProject: test-20240202
 * @BelongsPackage: PACKAGE_NAME
 * @CreateTime : 2024/2/2 22:36
 * @Description: 锁策略 & synchronized
 * @Author: code_hlb
 */
public class Locker {
    // 一、常见的锁策略
    // 1、通过预测接下来锁冲突的概率，分为 乐观锁/悲观锁
    // 2、通过实际消耗的开销，分为 轻量级锁/重量级锁
    // 3、自旋锁：轻量级锁的典型实现，往往是在纯用户态下实现（通过类似while循环不断判断锁是否被释放，忙等,消耗了cpu，但是换来了更快的响应速度）
    //    挂起等待锁：重量级锁的典型实现，要借助系统API实现，一旦出现锁竞争，就会在内核中触发一系列动作，例如挂起等待(阻塞)
    // 4、读写锁：把加锁分成了两种形式
    //  读锁：只允许读，不允许写，读锁和读锁之间不会发生竞争，因为多线程读取同一个数据并不会造成线程安全问题
    //  写锁：不允许读，也不允许写，读锁和写锁之间/写锁和写锁 之间都会发生锁竞争
    // 数据库事物隔离性中也有读写锁
    //  针对“脏读” 采用了写加锁：写的时候不允许读
    //  针对“不可重复读” 采用了读加锁：读的时候不允许写
    //  针对“幻读” 采用串行化方式，阻止了并发执行
    // 5、可重入锁/不可重入锁：一个线程对同一把锁连续加锁两次，没有发生死锁，就是可重入锁，反之就是不可重入锁
    // 6、公平锁/非公平锁：公平锁指线程按照“先来后到”的顺序获取锁，非公平锁指线程按照“概率均等”的方式重新竞争锁，操作系统提供的加锁API默认就是“非公平锁”
    // 二、synchronized
    // 2.1 对于"悲观乐观"，它是自适应的
    // 2.2 对于"重量轻量"，它是自适应的
    // 2.3 对于"自旋 挂起等待"，它是自适应的
    // 2.4 不是读写锁
    // 2.5 是可重入锁
    // 2.6 是非公平锁
    // 三、synchronized 几个主要机制
    // 3.1 锁升级 [无锁 --> 偏向锁(只是标记，并不是真正的加锁，运行时触发) --> 自旋锁(轻量级锁) --> 重量级锁]
    // 3.2 锁消除: 也是一种编译器优化的手段(触发几率不高)，编译阶段时，编译器会判定你的加锁代码，、
    //     若判定结果表示这里不需要加锁，此时就会把synchronized优化掉
    //     StringBuilder: 不带synchronized
    //     StringBuffer: 带synchronized
    // 3.3 锁粗化：synchronized里的代码越多，说明粒度越粗，反之越细
    // 粒度细的代码，能够并发执行的逻辑更多，能够充分利用多核cpu资源，
    // 但是，如果细粒度的代码，被反复加锁解锁，就涉及到反复的锁竞争，此时可能还不如粗粒度的锁
}
